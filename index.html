<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<title>Body Subway — 3D Beautiful (Play with Body)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{--ui-bg: rgba(0,0,0,0.45); --accent:#00ffd5;}
  html,body{height:100%; margin:0; font-family:Inter, Arial, sans-serif; background:#000;}
  /* Camera background (video) */
  #cam {
    position:fixed; inset:0; width:100vw; height:100vh; object-fit:cover;
    filter:brightness(0.56) saturate(1.05) blur(0.3px);
    z-index:0;
  }
  /* three.js canvas */
  canvas#three-canvas { position:fixed; inset:0; z-index:1; display:block; }

  /* UI */
  #ui {
    position:fixed; z-index:4; left:12px; top:12px; color:#fff; display:flex; gap:12px; align-items:flex-start;
  }
  .panel {
    background:var(--ui-bg); padding:10px 12px; border-radius:10px; box-shadow:0 8px 24px rgba(0,0,0,0.6);
  }
  #menu { position:fixed; z-index:6; left:50%; top:50%; transform:translate(-50%,-50%); width:480px; max-width:90vw; text-align:center; background:linear-gradient(180deg,#07101a,#021018); color:#dff; border-radius:12px; padding:22px; box-shadow:0 30px 80px rgba(0,0,0,0.7); }
  #menu h1{ margin:0 0 8px; font-size:26px; color:var(--accent); text-shadow:0 6px 22px rgba(0,255,213,0.12); }
  #menu p{ margin:0 0 18px; color:#bfe; }
  button { background:linear-gradient(90deg,#00ffd5,#0099ff); border:none; padding:10px 16px; border-radius:8px; color:#002; font-weight:700; cursor:pointer; }
  button.alt { background:transparent; border:1px solid rgba(255,255,255,0.12); color:#dff; }
  #hud { position:fixed; z-index:5; right:12px; top:12px; display:flex; flex-direction:column; gap:10px; align-items:flex-end; }
  .stat { background:var(--ui-bg); padding:10px 14px; border-radius:10px; color:#fff; min-width:120px; text-align:right; }
  .stat strong { display:block; font-size:20px; color:var(--accent); }

  /* bottom hints */
  #hint { position:fixed; left:50%; bottom:20px; transform:translateX(-50%); z-index:5; background:rgba(0,0,0,0.45); color:#dff; padding:8px 12px; border-radius:12px; }

  /* small loader */
  #loading { position:fixed; left:12px; bottom:12px; z-index:5; color:#fff; background:var(--ui-bg); padding:8px 10px; border-radius:8px; }
</style>
</head>
<body>

<!-- Camera background -->
<video id="cam" autoplay playsinline muted></video>

<!-- three.js canvas appended by script (id=three-canvas) -->

<!-- UI -->
<div id="ui" style="display:none;">
  <div class="panel">
    <div style="font-size:12px;color:#bfe">Score</div>
    <div style="font-size:20px;color:var(--accent);font-weight:700" id="score">0</div>
  </div>
  <div class="panel">
    <div style="font-size:12px;color:#bfe">Speed</div>
    <div style="font-size:20px;color:var(--accent);font-weight:700" id="speed">1.0</div>
  </div>
</div>

<div id="hud" style="display:none;">
  <div class="stat">Combo <strong id="combo">0</strong></div>
  <div class="stat">Lives <strong id="lives">3</strong></div>
</div>

<div id="loading">Waiting camera & model...</div>

<div id="menu">
  <h1>Body Subway — 3D</h1>
  <p>Điều khiển bằng cơ thể: nghiêng trái/phải để chuyển làn • nhảy né vật thấp • cúi né vật cao<br>Chạy tại chỗ để tăng tốc</p>
  <div style="display:flex; gap:12px; justify-content:center;">
    <button id="btnStart">Start Game</button>
    <button id="btnHow" class="alt">How to Play</button>
  </div>
  <p style="margin-top:12px; font-size:12px; color:#ddd">Chạy bằng server (ví dụ: <code>python -m http.server</code>) để mở camera.</p>
</div>

<div id="hint">Status: waiting</div>

<!-- audio (optional remote sources) -->
<audio id="music" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_1d0f7d44f7.mp3?filename=upbeat-pop-11288.mp3" loop></audio>
<audio id="sCoin" src="https://freesound.org/data/previews/341/341695_526087-lq.mp3"></audio>
<audio id="sJump'"> </audio>

<script type="module">
/* ============================
  Body Subway 3D — Full file
  Dependencies via CDN:
   - three (module)
   - GLTFLoader
   - OrbitControls (for dev toggles)
   - TensorFlow MoveNet (pose-detection)
   - mediapipe/pose
  IMPORTANT: Run via server (http://localhost:8080 or HTTPS).
============================ */

import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';
import * as poseDetection from 'https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@0.0.7/dist/pose-detection.min.js';
import '@mediapipe/pose';

const camVideo = document.getElementById('cam');
const menu = document.getElementById('menu');
const btnStart = document.getElementById('btnStart');
const btnHow = document.getElementById('btnHow');
const hint = document.getElementById('hint');
const loading = document.getElementById('loading');

const ui = document.getElementById('ui');
const hud = document.getElementById('hud');
const scoreEl = document.getElementById('score');
const speedEl = document.getElementById('speed');
const comboEl = document.getElementById('combo');
const livesEl = document.getElementById('lives');
const music = document.getElementById('music');
const sCoin = document.getElementById('sCoin');

let detector = null;
let modelReady = false;
let camReady = false;

/* ---------------- camera setup ---------------- */
async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode:'user' }, audio:false });
    camVideo.srcObject = stream;
    await new Promise(r=>camVideo.onloadedmetadata = r);
    camReady = true;
    loading.innerText = 'Camera ready. Loading model...';
  } catch(e) {
    alert('Không thể mở camera. Hãy đảm bảo bạn chạy file trên server và cho phép camera.');
    loading.innerText = 'Camera error';
    throw e;
  }
}

/* ---------------- load pose model ---------------- */
async function loadPoseModel() {
  detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, { modelType: 'SinglePose.Lightning' });
  modelReady = true;
  loading.innerText = 'Model ready. Click Start.';
}

/* -------------- three.js scene -------------- */
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.domElement.id = 'three-canvas';
renderer.domElement.style.position = 'fixed';
renderer.domElement.style.left = '0';
renderer.domElement.style.top = '0';
renderer.domElement.style.zIndex = '1';
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 6, 14);

// Lights
const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 0.9);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(8, 12, 6);
scene.add(dir);

// ground / track
const track = new THREE.Mesh(
  new THREE.PlaneGeometry(18, 80, 1,1),
  new THREE.MeshStandardMaterial({ color:0x2b2b2b })
);
track.rotation.x = -Math.PI/2;
track.position.z = 20;
scene.add(track);

// lanes
const lanes = [-3.8, 0, 3.8];

/* -------- player 3D (GLB) -------- */
let playerMesh = null;
let playerTargetX = 0;
const loader = new GLTFLoader();
const modelURL = 'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb';
loader.load(modelURL, (gltf) => {
  playerMesh = gltf.scene;
  playerMesh.scale.set(1.3,1.3,1.3);
  playerMesh.position.set(0,0,0);
  scene.add(playerMesh);
  // try simple idle pose tweak
  playerMesh.rotation.y = Math.PI;
}, undefined, (err) => {
  console.error('Model load error', err);
  // fallback cube
  const cube = new THREE.Mesh(new THREE.BoxGeometry(1.2,1.8,0.8), new THREE.MeshStandardMaterial({ color:0xffcc00 }));
  playerMesh = cube;
  playerMesh.position.y = 0.9;
  scene.add(playerMesh);
});

/* -------- Coins & obstacles -------- */
const coins = [];
const obstacles = [];

function createCoinMesh() {
  const geo = new THREE.CylinderGeometry(0.45,0.45,0.18,24);
  const mat = new THREE.MeshStandardMaterial({ color:0xFFD700, metalness:1, roughness:0.2 });
  const m = new THREE.Mesh(geo, mat);
  m.rotation.x = Math.PI/2;
  return m;
}
function createObstacleMesh(isHigh=false) {
  const geo = new THREE.BoxGeometry(1.2, isHigh?2.0:1.0, 1.0);
  const mat = new THREE.MeshStandardMaterial({ color:0xff4444 });
  const o = new THREE.Mesh(geo, mat);
  o.position.y = isHigh?1.05:0.5;
  return o;
}

function spawnEntity(type='coin') {
  const laneIndex = Math.floor(Math.random()*3);
  const x = lanes[laneIndex];
  const z = camera.position.z + 80 + Math.random()*30;
  if (type === 'coin') {
    const c = createCoinMesh();
    c.position.set(x, 1.1, z);
    scene.add(c);
    coins.push({ mesh:c, lane:laneIndex });
  } else {
    const high = Math.random() < 0.35;
    const o = createObstacleMesh(high);
    o.position.set(x, high?1.1:0.5, z);
    scene.add(o);
    obstacles.push({ mesh:o, lane:laneIndex, high });
  }
}

// spawn rhythm
let spawnTimer = setInterval(()=> {
  spawnEntity(Math.random() < 0.65 ? 'coin' : 'obstacle');
}, 900);

/* ---------- Game state ---------- */
let gameRunning = false;
let playerLane = 1;
let jumping = false;
let ducking = false;
let score = 0;
let combo = 0;
let lives = 3;
let baseSpeed = 0.9;
let speed = baseSpeed;

/* ---------- Pose detection loop & controller ---------- */
let lastNoseX = null, lastNoseY = null;
let lastLeftAnkleY = null, lastRightAnkleY = null;
let lastLeftKneeY = null, lastRightKneeY = null;

async function poseLoop() {
  if (!gameRunning || !detector || !camVideo) { requestAnimationFrame(poseLoop); return; }
  try {
    const poses = await detector.estimatePoses(camVideo);
    if (poses && poses.length > 0) {
      const p = poses[0];
      const kp = p.keypoints;

      const nose = kp[0]; // nose
      const lAnk = kp[15], rAnk = kp[16];
      const lKnee = kp[13], rKnee = kp[14];

      // lane control by nose x delta
      if (nose.score > 0.35 && lastNoseX !== null) {
        const dx = nose.x - lastNoseX;
        if (dx < -18 && playerLane > 0) { playerLane--; playerTargetX = lanes[playerLane]; }
        if (dx > 18 && playerLane < 2) { playerLane++; playerTargetX = lanes[playerLane]; }
      }
      if (nose.score > 0.35) lastNoseX = nose.x;

      // jump detection by nose y decreasing
      if (nose.score > 0.35 && lastNoseY !== null) {
        if (nose.y < lastNoseY - 20) triggerJump();
        if (nose.y > lastNoseY + 20) triggerDuck();
      }
      if (nose.score > 0.35) lastNoseY = nose.y;

      // speed estimation: ankle/knee movement amplitude
      let amp = 0;
      if (lAnk.score > 0.2 && rAnk.score > 0.2) {
        if (lastLeftAnkleY !== null) amp += Math.abs(lAnk.y - lastLeftAnkleY);
        if (lastRightAnkleY !== null) amp += Math.abs(rAnk.y - lastRightAnkleY);
        lastLeftAnkleY = lAnk.y; lastRightAnkleY = rAnk.y;
      } else if (lKnee.score > 0.2 && rKnee.score > 0.2) {
        if (lastLeftKneeY !== null) amp += Math.abs(lKnee.y - lastLeftKneeY);
        if (lastRightKneeY !== null) amp += Math.abs(rKnee.y - lastRightKneeY);
        lastLeftKneeY = lKnee.y; lastRightKneeY = rKnee.y;
      }
      const boost = Math.min(1.6, amp * 60);
      speed = speed * 0.92 + (baseSpeed + boost) * 0.08;
    }
  } catch (e) {
    console.warn('pose err', e);
  }
  updateHUD();
  requestAnimationFrame(poseLoop);
}

/* ---------- actions ---------- */
function triggerJump() {
  if (jumping) return;
  jumping = true; combo = 0;
  setTimeout(()=> jumping=false, 600);
}
function triggerDuck() {
  if (ducking) return;
  ducking = true; combo = 0;
  setTimeout(()=> ducking=false, 700);
}

/* ---------- collisions & scoring ---------- */
function updateGameLogic() {
  if (!playerMesh) return;

  // player world pos
  const playerPos = new THREE.Vector3();
  playerMesh.getWorldPosition(playerPos);

  // coins
  for (let i = coins.length - 1; i >= 0; i--) {
    const c = coins[i];
    const d = c.mesh.position.distanceTo(playerPos);
    if (d < 1.1 && Math.abs(c.mesh.position.z - playerPos.z) < 2.5) {
      scene.remove(c.mesh);
      coins.splice(i,1);
      score += 10;
      combo += 1;
      sPlayCoin();
      speed += 0.08;
    }
  }

  // obstacles
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const o = obstacles[i];
    const d = o.mesh.position.distanceTo(playerPos);
    if (d < 1.5 && Math.abs(o.mesh.position.z - playerPos.z) < 2.5) {
      if ((o.high && ducking) || (!o.high && jumping)) {
        // avoided
        score += 5; combo += 1;
      } else {
        // hit
        score = Math.max(0, score - 20);
        combo = 0; lives -=1;
        if (lives <= 0) endGame();
      }
      scene.remove(o.mesh);
      obstacles.splice(i,1);
    }
  }
}

/* ---------- HUD ---------- */
function updateHUD() {
  scoreEl.innerText = Math.floor(score);
  speedEl.innerText = speed.toFixed(2);
  comboEl.innerText = combo;
  livesEl.innerText = lives;
}

/* ---------- audio helpers ---------- */
function sPlayCoin() {
  try { sCoin.currentTime = 0; sCoin.play(); } catch(e){}
}

/* ---------- render loop ---------- */
function animate() {
  requestAnimationFrame(animate);

  if (playerMesh) {
    // smooth lane follow
    playerMesh.position.x += (playerTargetX - playerMesh.position.x) * 0.14;
    // jump arc
    if (jumping) {
      playerMesh.position.y = 1.0 * Math.sin(Math.min((Date.now()%700)/700,1) * Math.PI);
    } else {
      playerMesh.position.y += (0 - playerMesh.position.y) * 0.12;
    }
    // duck scale
    if (ducking) playerMesh.scale.y += (0.72 - playerMesh.scale.y) * 0.16;
    else playerMesh.scale.y += (1 - playerMesh.scale.y) * 0.12;
  }

  // move coins and obstacles toward camera
  const forward = speed * 0.92;
  for (let i = coins.length -1; i >= 0; i--) {
    coins[i].mesh.position.z -= forward;
    coins[i].mesh.rotation.y += 0.06;
    if (coins[i].mesh.position.z < camera.position.z - 12) {
      scene.remove(coins[i].mesh);
      coins.splice(i,1);
    }
  }
  for (let i = obstacles.length -1; i >= 0; i--) {
    obstacles[i].mesh.position.z -= forward;
    if (obstacles[i].mesh.position.z < camera.position.z - 12) {
      scene.remove(obstacles[i].mesh);
      obstacles.splice(i,1);
    }
  }

  // random extra coin bursts
  if (Math.random() < 0.015) spawnEntity('coin');

  // collision detection with player
  updateGameLogic();

  renderer.render(scene, camera);
}

/* ---------- start / end ---------- */
function startGameSession() {
  if (!camReady || !modelReady) {
    alert('Camera hoặc model chưa sẵn sàng. Đảm bảo đã cho phép camera và model tải xong.');
    return;
  }
  menu.style.display = 'none';
  ui.style.display = 'flex';
  hud.style.display = 'flex';
  loading.style.display = 'none';
  hint.innerText = 'Game running — nghiêng/nâng/nhảy/cúi để điều khiển';
  gameRunning = true;
  // begin pose loop & render
  poseLoop();
  animate();
  try { music.currentTime = 0; music.play(); } catch(e){}
}

function endGame() {
  gameRunning = false;
  alert('Game Over\nScore: ' + Math.floor(score));
  location.reload();
}

/* ---------- helpers ---------- */
function spawnInitialBurst() {
  for (let i=0;i<8;i++){
    if (Math.random() < 0.6) spawnEntity('coin'); else spawnEntity('obstacle');
  }
}

/* ---------- UI handlers ---------- */
btnStart.onclick = async () => {
  try {
    loading.innerText = 'Starting camera...';
    await startCamera();
    loading.innerText = 'Loading model...';
    await loadPoseModel();
    loading.innerText = 'Ready';
    camVideo = camVideo; // for linter
    camVideo = document.getElementById('cam');
    // set cam attributes
    camVideo.style.zIndex = 0;
    btnStart.innerText = 'Play';
    startGameSession();
    spawnInitialBurst();
  } catch(e) {
    console.error(e);
  }
};

btnHow.onclick = () => {
  alert('How to play:\n- Nghiêng người trái/phải để đổi làn\n- Nhảy lên để né chướng ngại thấp\n- Cúi xuống để né chướng ngại cao\n- Chạy tại chỗ (đá chân) để tăng tốc\n\nLưu ý: chạy file bằng server (python -m http.server) để camera hoạt động.');
};

/* ---------- initial load ---------- */
(async () => {
  // pre-load camera permission prompt when Start clicked; we start only after Start
  // but we can prefetch model to reduce wait time:
  loading.innerText = 'Preloading model (may take 1-3s)...';
  try {
    await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, { modelType:'SinglePose.Lightning' });
    loading.innerText = 'Model preloaded. Click Start.';
    modelReady = true;
  } catch(e) {
    console.warn('Preload failed, will load on Start', e);
    loading.innerText = 'Model will load on Start.';
  }
})();

/* ---------- ensure resize ---------- */
window.addEventListener('resize', ()=> {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>

</body>
</html>
